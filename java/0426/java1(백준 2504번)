/*
괄호의 값 출처분류
시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
1 초	128 MB	28146	6956	5285	28.052%
문제
4개의 기호 ‘(’, ‘)’, ‘[’, ‘]’를 이용해서 만들어지는 괄호열 중에서 올바른 괄호열이란 다음과 같이 정의된다.

한 쌍의 괄호로만 이루어진 ‘()’와 ‘[]’는 올바른 괄호열이다. 
만일 X가 올바른 괄호열이면 ‘(X)’이나 ‘[X]’도 모두 올바른 괄호열이 된다. 
X와 Y 모두 올바른 괄호열이라면 이들을 결합한 XY도 올바른 괄호열이 된다.
예를 들어 ‘(()[[]])’나 ‘(())[][]’ 는 올바른 괄호열이지만 ‘([)]’ 나 ‘(()()[]’ 은 모두 올바른 괄호열이 아니다. 우리는 어떤 올바른 괄호열 X에 대하여 그 괄호열의 값(괄호값)을 아래와 같이 정의하고 값(X)로 표시한다. 

‘()’ 인 괄호열의 값은 2이다.
‘[]’ 인 괄호열의 값은 3이다.
‘(X)’ 의 괄호값은 2×값(X) 으로 계산된다.
‘[X]’ 의 괄호값은 3×값(X) 으로 계산된다.
올바른 괄호열 X와 Y가 결합된 XY의 괄호값은 값(XY)= 값(X)+값(Y) 로 계산된다.
예를 들어 ‘(()[[]])([])’ 의 괄호값을 구해보자.  ‘()[[]]’ 의 괄호값이 2 + 3×3=11 이므로  ‘(()[[ ]])’의 괄호값은 2×11=22 이다. 그리고  ‘([])’의 값은 2×3=6 이므로 전체 괄호열의 값은 22 + 6 = 28 이다.

여러분이 풀어야 할 문제는 주어진 괄호열을 읽고 그 괄호값을 앞에서 정의한대로 계산하여 출력하는 것이다. 

입력
첫째 줄에 괄호열을 나타내는 문자열(스트링)이 주어진다. 단 그 길이는 1 이상, 30 이하이다.

출력
첫째 줄에 그 괄호열의 값을 나타내는 정수를 출력한다. 만일 입력이 올바르지 못한 괄호열이면 반드시 0을 출력해야 한다. 

예제 입력 1 
(()[[]])([])
예제 출력 1 
28
*/

// 풀이
import java.util.*;

public class Main {
	
	public static void main(String[] args) {
		
		Scanner sc = new Scanner(System.in);
    // stack을 이용하여 정답 유무 판단 예정
		Stack<Character> st = new Stack<>();
		String input = sc.nextLine();
    // 정답 ans
		int ans = 0;
    // 숫자 조합용 num
		int num = 1;
		char before;
    
    // 문제의 풀이는 괄호 안부터 하지 않고, 전개해서 푼다고 생각하면 편하다.
    // 예를 들어 2*(3+2) -> 2*3 + 2*4
    // 시작은 '(', '['로 해야 정상이므로 이걸로 시작할 때 num에 그것을 곱하여 해당 숫자로 시작하도록 한다.
    // 이후 또다시 '(', '['가 나오면 앞의 괄호 안에 있는 수이므로 곱해주면 된다. 또 나오는 경우 그걸 더하면 된다.
    // 그렇다면 1번 괄호 내에서 2번 괄호가 열렸다가 닫히고, 3번 괄호가 다시 열리는 경우 1*2를 하고 1*3을 진행하면 되기 때문에 ']', ')'가 나왔을 때에는 앞의 괄호가 끝맺을 수 있는 경우 닫고, 나누어 주면 된다.
    // 이런 식으로 진행한다.
		
		for(int i=0; i<input.length(); i++) {
      // 현재 값 now를 통해 판단
			char now = input.charAt(i);
			if(now == '(') {  // 먼저 '('인 경우
				st.push(now);   // 스택에 현재값 저장
				num *= 2;       // 2배해준다. 
			}
			else if(now == '[') { //위와 비슷한데 얘는 3배한다.
				st.push(now);
				num *= 3;
			}
			else if(now == ']') { // 닫히는 경우
				if(st.empty() || st.peek() != '[') {  // 먼저 앞에가 잘못된 경우
					ans = 0;    // 값은 0이 된다.
					break;
				}
				before = st.pop();  // 값을 하나 빼준다. 굳이 pop을 쓸 이유는 없음
				if(input.charAt(i-1) == '[')    // 이것보다 앞에가 '['인 경우만 정답 더함
					ans += num;
				num /= 3;           // 수식 진행했으므로 나누기 3
				
			}
			else if(now == ')'){    // 위와 비슷하게 진행한다.
				if(st.empty() || st.peek() != '(') {
					ans = 0;
					break;
				}

				before = st.pop();
				if(input.charAt(i-1) == '(')
					ans += num;
				num /= 2;
				
			}
		}   // 만약에 (나 [로 끝나거나 제대로 끝나지 않으면 0으로 만듬.
        if(!st.empty()) ans = 0;
        
		System.out.println(ans);
		
		
	}
}
