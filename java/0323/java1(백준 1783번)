/*

1783번
제출
맞은 사람
숏코딩
재채점
채점 현황
내 제출
 난이도 기여
강의
질문 검색
병든 나이트 성공분류
시간 제한	메모리 제한	제출	정답	맞은 사람	정답 비율
2 초	128 MB	7269	3137	2681	43.110%
문제
병든 나이트가 N × M 크기 체스판의 가장 왼쪽아래 칸에 위치해 있다. 병든 나이트는 건강한 보통 체스의 나이트와 다르게 4가지로만 움직일 수 있다.

2칸 위로, 1칸 오른쪽
1칸 위로, 2칸 오른쪽
1칸 아래로, 2칸 오른쪽
2칸 아래로, 1칸 오른쪽
병든 나이트는 여행을 시작하려고 하고, 여행을 하면서 방문한 칸의 수를 최대로 하려고 한다. 병든 나이트의 이동 횟수가 4번보다 적지 않다면, 이동 방법을 모두 한 번씩 사용해야 한다. 이동 횟수가 4번보다 적은 경우(방문한 칸이 5개 미만)에는 이동 방법에 대한 제약이 없다.

체스판의 크기가 주어졌을 때, 병든 나이트가 여행에서 방문할 수 있는 칸의 최대 개수를 구해보자.

입력
첫째 줄에 체스판의 세로 길이 N와 가로 길이 M이 주어진다. N과 M은 2,000,000,000보다 작거나 같은 자연수이다.

출력
병든 나이트가 여행에서 방문할 수 있는 칸의 개수중 최댓값을 출력한다.

예제 입력 1 
100 50
예제 출력 1 
48
예제 입력 2 
1 1
예제 출력 2 
1
예제 입력 3 
17 5
예제 출력 3 
4
예제 입력 4 
2 4
예제 출력 4 
2
예제 입력 5 
20 4
예제 출력 5 
4
출처
문제를 번역한 사람: baekjoon
문제의 오타를 찾은 사람: gudori888, han1g, jh05013, luluctrl4, shnoh
알고리즘 분류
구현
그리디 알고리즘
Case work
*/

// 풀이
import java.util.*;
import java.io.IOException; 
public class Main {	
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(System.in);
		int A = sc.nextInt();
		int B = sc.nextInt();
		int ans = 0;

    // 먼저 세로가 1이면 이동을 못한다.
		if(A==1)
			ans = 1;
		else if(A==2) // 세로가 2면 위아래로는 한칸씩밖에 이동할 수 없다.
		{
			ans = (B-1)/2 + 1;  // 그렇다면 오른쪽으로 2칸씩 이동하게 되는데, B가 1,2 - 3,4 - 5,6 ...이런 식으로 증가할 때마다 한칸씩 도 이동할 수 있다.
			if(ans > 4)         // 다만 이경우 위아래 2칸씩 이동하는 것이 불가능하므로 최대 이동 가능 횟수는 4회이다.
				ans = 4;
		}
		else                  // 세로로 2칸보다 큰 경우 모든 이동 방법을 사용 가능하다.
		{
			ans = B-2;          // 1칸씩 이동하다가 마지막 4칸을 남기고 오른쪽 2칸으로 이동하는 방법 두 개를 사용한다. 그렇게 되면 2를 빼야한다.
			if(B < 7)           // 그런데 B가 6까지의 경우 전체 이동을 못한다.
			{
				ans = B;          // 위에랑 비슷하게 진행되긴 하는데 한칸씩 이동 가능하므로 ans = B에서 최대숫자가 4인식으로 진행한다.
				if(ans > 4)
					ans = 4;
			}
		}
		System.out.println(ans);
		
	}

}
	
